
Save/Load:

  NOTES:
    JSON format

  Save:
  d first, need state flow to work: MAIN -> Intro -> Menu -> Initialize -> NewGame -> Construct -> Play -> Destroy -> Menu -> Shutdown
  d then, need state flow to work: MAIN -> Intro -> Menu -> Initialize -> NewGame -> Construct -> Play -> Construct -> Play -> Destroy -> Menu -> Shutdown
  d save Random Seed [for the whole game, not just the level]
  o save version with each section
  o save IDs and a table that maps IDs to entities
  o get state flow to work: MAIN -> Intro -> Menu -> Initialize -> NewGame -> Construct -> Play -> Save -> Destroy -> Menu -> Shutdown
  o get state flow to work: MAIN -> Intro -> Menu -> Initialize -> LoadGame -> Construct -> Play -> Save -> Destroy -> Menu -> Shutdown

  Load:
  o read ID table on load before loading entities
  o sanity checking; if data is corrupt or invalid, warn the user and load default values instead.
  o silently skip sections that are not supported. (for version compatibility). Warn the player when this happens.
  o get state flow to work: MAIN -> Intro -> Menu -> Initialize -> LoadGame -> Construct -> Play -> Destroy -> Menu -> Shutdown

Interface:

  NOTES:
    State Flow:
    MAIN -> Intro -> Menu
      Menu -> Initialize
      Menu -> Options
      Menu -> Help
      Menu -> Shutdown
        Initialize -> LoadGame
        Initialize -> NewGame
        Options -> Menu
        Help -> Menu
          LoadGame -> Construct
          NewGame -> Construct
            Construct -> Play
              Play -> Construct
              Play -> Options
              Play -> Help
              Play -> Save (and quit)
              Play -> Destroy (quit without saving)
                Options -> Play
                Help -> Play
                Save -> Destroy
                Destroy -> Menu
                  Destroy -> Menu

    Individual States and their potential links:
      State:        From:                           To:
      MAIN          --                              Intro
      Intro         MAIN                            Menu
      Menu          Intro, Options, Help, Destroy   Initialize, Options, Help, Shutdown
      Initialize    Menu                            NewGame, LoadGame
      LoadGame      Initialize                      Construct
      NewGame       Initialize                      Construct
      Options       Menu, Play                      Menu, Play
      Help          Menu, Play                      Menu, Play
      Construct     LoadGame, NewGame, Play         Play
      Play          Construct, Options, Help        Construct, Options, Help, Save, Destroy
      Save          Play                            Destroy
      Destroy       Play, Save                      Menu
      Shutdown      Menu                            --

  d fix play state init,enter,leave so that it can leave [to a menu state, for example] without destroying anything, and come back. Or it can leave [to shutdown or main menu state] and kill everything.
  o Need another draw routine in RenderSystem for drawing outside of camera translation.
  o TooltipComponent... mouseover info panel thingy
  o   property.DrawStrategy (mouse, fixedPosition, leftOrRightScreenHalf)
  o   Add a description field to JSON files.
  o   And a Portrait field.
  x UISystem - handles User Interface

For v0.1.0:
  o save/load
  o interface



BEYOND v0.1.0:

  Items:
  o Entity Inventory [this could also be used for bags? Item with an inventory?]
  o   UsableComponent? [this needs scripting in JSON files]
  o     UseCommand [call onUse(), potentially destroy entity]
  o id as hex value

  Input/Events/Config:
  o KeyEvents and MouseEvents should interpret the input into game events and send those rather than the raw input. [e.g. pressing Ctrl-S should send a SAVE_EVENT, not a KEY_EVENT(ctrl, s)]. Use keybindings for this.
  o read keybindings from a config file. [make a default config in the Pud dir]

  Console/Debug:
  - log console to file (with an option)
  - maybe different levels of messages [only log certain lines?]
  - allow input and create some awesome commands
  o every event and command needs a tostring method that is called when debugEvents is on.
  - wizard mode

  Level:
  - change Level representation of enemy to be by position in a table for faster lookup
  o dim area on screen should represent the hero's memory... entities and map objects should be drawn where they were last seen and in the state in which they were last seen. [no animation or updates]
  o Level templates
  o   Be able to specify type of level construction, maps to use, enemies to use (by elevel, family, kind, etc), items to use. For example: mausoleum maps with skeletons and bone weapons, monastary maps with monks (any family) and magic armor, etc.
  o make stairs work [generate new map]

  Expressions:
  ? how to implement scripting? Use a potion -> add x to health of containing mediator. Use a hammer -> knock back enemy. Sword occasionally sings?

    Example of use:
    "+USE_ENTITY": "@Owner:send(HEALTH_MODIFY, 12) @Destroy()",
    "+COMBAT_HIT": "@Target:send(KNOCK_BACK, 2)",
    "+TIME_TICK": "@OnChance(1, 10, @RandomChoice(%SayMessage))",
    "%SayMessage": {
      "Hey! Watup?",
      "Let me at em! Let me at em!",
      "Honk if you're horny!",
    },

  Graphics:
  - make hero movement smoother [tweened... possibly only move camera when near edges?]
  o support sprite batches if framebuffers are unsupported

  Map:
  - map as quad-tree [or something?]
  ? maptypes as composites?
  - poisson disk sampling for decoration/item/monster placement [map gen too?]
  o map tiles like doors and stairs should be drawn above actual floor instead of incorporating floor into their tile [or should be objects rather than MapTypes]
  o   they should be collidable and send an event on collision [e.g. door collision asks entity if it has CanOpenDoors property, if so, sends DoorOpenEvent. trap collision triggers one of various TrapEvents.]
  ? How to handle map deformation? Would like ability to mine/dig/etc.
  o Create another View that can show simple representation of map nodes for Minimap.
  o and another View that can show some representation of nodes on a level beneath the current one [for pits, chasms, digging down, etc].
  o TileMapNodeView should listen for messages from its MapNode to determine if the node's type changed (for update() and _resetKey())

  Other:
  - fix tests

NOTES & IDEAS:
