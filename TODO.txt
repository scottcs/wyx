[X] change FileMapLoader to consider all files in map dir
[X] change dungeon sets to mix colors for walls, floors and stairs
[ ] add monsters
[ ]   blocking code belongs in CollisionComponent
[ ]   drawing code in GraphicsComponent
[ ] save/load
[ ] add combat
[ ] add interface
[ ] add items (as composites?)
[ ] maptypes as composites?
[ ] make stairs work (generate new map)
[ ] wizard mode
[ ] map as quad-tree (or something)?
[ ] poisson disk sampling for decoration/item/monster placement (map gen too?)
[ ] can hero background be transparent?
[ ] make hero movement smoother (possibly only move camera when near edges?)
[-] don't animate or update dim tiles
[-] support sprite batches if framebuffers are unsupported

NOTES:
* ModelComponent - game data and helper methods
  - HealthComponent
  - TimeComponent
  - CombatComponent
* ViewComponent - anything that will be rendered
  - GraphicsComponent
* ControllerComponent - anything that modifies the model
  - InputComponent
  - AIComponent
* RenderWrangler (or RenderManager, or GraphicsSubsystem, or something)
  - Cycles through array of registered ViewComponents and asks them to draw().
* EntityFactory queries new Entity for all ViewComponents, asks them to
  register with RenderWrangler.
* Entity knows nothing about Component implementations. It contains no state
  like position or visual representation.
  - This means remove Rect inheritance and add position to a ModelComponent.
  - DEFINE: it contains "lifetime management" and "identifier scoping".
  - DEFINE: can query components for type.

* Properties
  - want to assume it's lua code if not property.isproperty? If so, then the
    whole property() thing is useless.

* Events
  - make sure event registration is a weak table
  - Don't have chains of objects observing other objects, observing other
    objects. One layer of observer relationships is best (unless you use an
    Event Aggregator).
      - this is because it is very hard to debug. it's not obvious where calls
        came from because they are messages sent at some point from somewhere.
  - currently I am queueing and flushing events... is this necessary or even
    wise? Might account for performance issues? Look into it!

* Object construction
  - write a helper new() function to automatically require the given class and
    return a new object of that class? Like:
      new(class, ...)
        local Class = require class
        return Class(...)
      end
  - it could even try to be smart about the class path? So instead of:
      new('pud.event.component.GraphicsComponent', ...)
    you could just call:
      new('GraphicsComponent', ...)
  - is this terrible design or clever design??
