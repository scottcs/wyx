Interface:
  x perhaps a push() and pop() for RunState? [useful for Play -> PlayMenu -> Options, etc]
  o TooltipComponent... mouseover info panel thingy
  o   property.DrawStrategy (mouse, fixedPosition, leftOrRightScreenHalf)
  o   Add a description field to JSON files.
  o   And a Portrait field.
  ?   how to show damage range? [since it's usually a function]
	o     execute 100 [or 1000] times on load, then cache min/max values
	o     or, do away with dice rolls, specify min/max instead
	o Main game interface
	o   Design what it should look like before coding it
	o   Inventory/Equipment in a line along bottom
	?   Score or some way to show progress?
  d UISystem
	d   ticks registered UI Frames
	d   draws registered UI Frames [draw after camera translation]
	d   listens for user input - mouse and keyboard
	-     sends events [based on configured keybindings eventually] translated from input

	UI Elements:
	d Styles
	d   Has background or overlay color
	d   Has a font
	d   Has a fontcolor
	d   Has a background image
	d     if image, color = overlay
	d     if not image, color = background and rectangle is drawn
	o   Needs a border that is drawn on top of everything else
	d Frames
	d   Have hover/press checks, call onHover, onPress
	d   Has Styles
	d   Can just display an image if needed
	d   onClick - depth first, and don't pass it on if you handle it
	o   can attach/detach a Tooltip
	d Text [subclass Frame]
	d   Displays text
	d   Wraps text
	d   Wraps text correctly based on pixel size
	d   Can watch a variable
	d Buttons [subclass Text]
	d   Can be pressed, hovered
	d   Has an optional callback when pressed
	d TextEntry [subclass Text]
	d   allows multi-line input with backspace and enter
	d   with cursor
	d   Has an optional callback when editing stops
	o Tooltip [subclass Frame] [background and color set as normal... if an image, should be a texture, and color should be slightly transparent by default]
	o   default background color is slightly transparent black
	o   scales well with its content
	o   has a border that is drawn [scales with size of tooltip]
	o   contains an Icon [top left]
	o   contains a Title [top right]
	o   contains one or more info lines
	o     can be a Text frame
	o     can be a Bar frame
	o     can be an InfoBar frame
	o     can be a blank vertical space
	o custom mouse cursor
	o Slots [subclass Button]
	o   Can contain another image within its border [an item, for instance]
	o   Can watch a variable
	o   When clicked, change mouse cursor
	d Bar [subclass Frame]
	d   Has a min and max and current value
	d   Can watch a variable
	x   Animation?
	o Info bar [health bar, etc] [subclass Frame]
	o   optional Text as cur/max or as %
	o      can position text anywhere
	o   optional Text as label
	o      can position anywhere
	x   Dual-layer? background min/max/current as well? [could be used to show temporary gain/loss]
	- Quick Menu [post 0.1.0 probably... something to allow large inventory]
	- Minimap
	- Ability to click on entities/map tiles directly
	?   Context menu
	?   Click-to-move?

	Options / Config:
	- key bindings

For v0.1.0:
  o interface
	o rename this game



BEYOND v0.1.0:

Save/Load:
  Event Queues:
  ? current state of queues? or just ignore?
  o sanity checking; if data is corrupt or invalid, warn the user and load default values instead.
  o silently skip sections that are not supported. (for version compatibility). Warn the player when this happens [errm... but that's not "silently"].

Items:
  o UsableComponent? [this needs scripting in JSON files]
  o   UseCommand [call onUse(), potentially destroy entity]

Input/Events/Config:
  o KeyEvents and MouseEvents should interpret the input into game events and send those rather than the raw input. [e.g. pressing Ctrl-S should send a SAVE_EVENT, not a KEY_EVENT(ctrl, s)]. Use keybindings for this.
  o read keybindings from a config file. [make a default config in the Pud dir]

Console/Debug:
  - log console to file (with an option)
  - maybe different levels of messages [only log certain lines?]
  - allow input and create some awesome commands
  o every event and command needs a tostring method that is called when debugEvents is on.
  - wizard mode
	+ printing to Console while rendertarget is set to something else has strange implications

Level:
  - change Level representation of enemy to be by position in a table for faster lookup
  o dim area on screen should represent the hero's memory... entities and map objects should be drawn where they were last seen and in the state in which they were last seen. [no animation or updates]
  o Level templates
  o   Be able to specify type of level construction, maps to use, enemies to use (by elevel, family, kind, etc), items to use. For example: mausoleum maps with skeletons and bone weapons, monastary maps with monks (any family) and magic armor, etc.
  o make stairs work [generate new map]
	+ maps should be referenced by ID like entities [with portals, anyway]

Expressions:
  ? how to implement scripting? Use a potion -> add x to health of containing mediator. Use a hammer -> knock back enemy. Sword occasionally sings?

    Example of use:
    "+USE_ENTITY": "@Owner:send(HEALTH_MODIFY, 12) @Destroy()",
    "+COMBAT_HIT": "@Target:send(KNOCK_BACK, 2)",
    "+TIME_TICK": "@OnChance(1, 10, @RandomChoice(%SayMessage))",
    "%SayMessage": {
      "Hey! Watup?",
      "Let me at em! Let me at em!",
      "Honk if you're horny!",
    },

Graphics:
  x make hero movement smoother [tweened... possibly only move camera when near edges?]
  - support sprite batches if framebuffers are unsupported
	+ fix wrong dungeon colors after load
	+    styles should be set in model, not in view [or do away with random styles and assign meaning to the tiles]

Sound:
  o add sounds
	o add music

Map:
  x map as quad-tree [or something?]
  ? maptypes as composites?
  - poisson disk sampling for decoration/item/monster placement [map gen too?]
  + map tiles like doors and stairs should be drawn above actual floor instead of incorporating floor into their tile [or should be objects rather than MapTypes]
  +   they should be collidable and send an event on collision [e.g. door collision asks entity if it has CanOpenDoors property, if so, sends DoorOpenEvent. trap collision triggers one of various TrapEvents.]
  ? How to handle map deformation? Would like ability to mine/dig/etc.
  o Create another View that can show simple representation of map nodes for Minimap.
  o and another View that can show some representation of nodes on a level beneath the current one [for pits, chasms, digging down, etc].
  o TileMapNodeView should listen for messages from its MapNode to determine if the node's type changed (for update() and _resetKey())

Other:
  - fix tests
	+ make EntityRegistry not a global [it's in the World]

NOTES & IDEAS:

Interface:

  RunState Flow:
    MAIN -> Intro -> MainMenu
      MainMenu -> Initialize
      MainMenu -> Options
      MainMenu -> Help
      MainMenu -> Shutdown
        Initialize -> LoadGame
        Initialize -> Construct
        Options -> MainMenu
        Help -> MainMenu
          LoadGame -> Construct
            Construct -> Play
              Play -> PlayMenu
                PlayMenu -> Options
                PlayMenu -> Help
                PlayMenu -> Save
                PlayMenu -> Destroy (quit without saving)
                  Options -> PlayMenu
                  Help -> PlayMenu
                  Save -> PlayMenu
                  Save -> Destroy
                  Destroy -> MainMenu
                    Destroy -> MainMenu

  Individual States and their potential links:
      RunState:     From:                           To:
      MAIN          --                              Intro
      Intro         MAIN                            MainMenu
      MainMenu      Intro, Options, Help, Destroy   Initialize, Options, Help, Shutdown
      Initialize    MainMenu                        Construct, LoadGame
      LoadGame      Initialize                      Construct
      Options       MainMenu, PlayMenu              MainMenu, PlayMenu
      Help          MainMenu, PlayMenu              MainMenu, PlayMenu
      Construct     LoadGame, Initialize            Play
      Play          Construct                       PlayMenu
      PlayMenu      Play, Options, Help, Save       Options, Help, Save, Destroy
      Save          PlayMenu                        Destroy, PlayMenu
      Destroy       PlayMenu, Save                  MainMenu
      Shutdown      MainMenu                        --

  Loops:
      MainMenu -> Help -> MainMenu
      MainMenu -> Options -> MainMenu
      Play -> PlayMenu -> Play
      PlayMenu -> Help -> PlayMenu
      PlayMenu -> Options -> PlayMenu
      PlayMenu -> Save -> PlayMenu
      MainMenu -> Initialize -> (LoadGame ->) Construct -> Play -> PlayMenu -> (Save ->) Destroy -> MainMenu

