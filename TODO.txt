Items:
  d make some test item files
  d randomly place items in the level
  d Entity container class.
  d   Sortable by property.
  d   Uses IDs.
  o Entity Inventory [this could also be used for bags? Item with an inventory?]
  d   InventoryComponent? ContainerComponent? [these need to be sent messages, but not queried]
  d     PickupCommand [Put in container from level]
  d     DropCommand [Put in level from container]
  d   EquipmentComponent? AttachedEntityComponent?  [could be used to attach enemies to enemies? like parasites? or like voltron? - these entities are queried when parent entity is queried, and are sent messages]
  d     AttachCommand [Equip - from container]
  d     DetachCommand [Unequip - to container]
  o   UsableComponent? [this needs scripting in JSON files]
  o     UseCommand [call onUse(), potentially destroy entity]

Console:
  - log console to file (with an option)
  - maybe different levels of messages [only log certain lines?]
  - allow input and create some awesome commands

Level:
  - change Level representation of enemy to be by position in a table for faster lookup
  o support lua in properties when read from file
  o   or at least formulas... like 1d20 or whatever [would still need access to properties, too, like 2d10 * Level... something]
  +   this needs to be done in EntityDB AND in Component
  +     evaluate correct syntax in EntityDB on load
          if Expression.isExpression(data) then
            data = Expression.makeFunction(data) [check for loops... build a graph?]
          end
  +     calculate average value when determining ELevel [how to do this before entity created?]
          if type(data) == 'function' then
            local sum = 0
            for i=1,100 do sum = sum + data() end
            return _round(sum/100)
          end
  +     evaluate actual value on getProperty
          if type(data) == 'function' then
            result = data(self._mediator)
          end

Components:
  o TooltipComponent... mouseover info panel thingy
  o   property.DrawStrategy (mouse, fixedPosition, leftOrRightScreenHalf)
  o   Add a description field to JSON files.
  o   And a Portrait field.
  - UISystem - handles User Interface

Interface:
  o Need another draw routine in RenderSystem for drawing outside of camera translation.

Other:
  - fix tests
  - fix play state init,enter,leave so that it can leave [to a menu state, for example] without destroying anything, and come back. Or it can leave [to shutdown or main menu state] and kill everything.

For v0.1.0:
  o items
  o save/load
  o interface

Beyond v0.1.0:
  o dim area on screen should represent the hero's memory... entities and map objects should be drawn where they were last seen and in the state in which they were last seen.
  o make stairs work [generate new map]
  - wizard mode
  - make hero movement smoother [tweened... possibly only move camera when near edges?]
  x support sprite batches if framebuffers are unsupported
  o Level templates
  o   Be able to specify type of level construction, maps to use, enemies to use (by elevel, family, kind, etc), items to use. For example: mausoleum maps with skeletons and bone weapons, monastary maps with monks (any family) and magic armor, etc.

  Map:
  - map as quad-tree [or something?]
  ? maptypes as composites?
  - poisson disk sampling for decoration/item/monster placement [map gen too?]
  o map tiles like doors and stairs should be drawn above actual floor instead of incorporating floor into their tile [or should be objects rather than MapTypes]
  o   they should be collidable and send an event on collision [e.g. door collision asks entity if it has CanOpenDoors property, if so, sends DoorOpenEvent. trap collision triggers one of various TrapEvents.]
  ? How to handle map deformation? Would like ability to mine/dig/etc.
  o Create another View that can show simple representation of map nodes for Minimap.
  o and another View that can show some representation of nodes on a level beneath the current one [for pits, chasms, digging down, etc].
  o TileMapNodeView should listen for messages from its MapNode to determine if the node's type changed (for update() and _resetKey())
  x don't animate or update dim tiles


NOTES:

Creating Property functions:

  "Attack": "=2d5+32"
    becomes
  function(e) return Random:dice_roll("2d5+32") end

  "Attack": "=19 + 2d5+32"
    becomes
  function(e) return 19 + Random:dice_roll("2d5+32") end

  "Attack": "=Defense + 2d5+32"
    becomes
  function(e) return e:query(property('Defense')) + Random:dice_roll("2d5+32") end

  "Attack": "=HealthMax / 10"
    becomes
  function(e) return (e:query(property('HealthMax')) / 10) end

  "OnDeath": "=Explode(12, 20)"
    becomes
  function(e) return e:doExplode(12, 20) end

